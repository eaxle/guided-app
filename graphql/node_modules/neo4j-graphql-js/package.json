{
  "_from": "neo4j-graphql-js",
  "_id": "neo4j-graphql-js@0.1.18",
  "_inBundle": false,
  "_integrity": "sha512-HVfQqZFk6gduE6rgjoRi0YIXI4AziEvdjIhbrbroGFgnAbC+Ub6BqAYDMXBN4d1o3YenjmkfeM1p3IPKddQ+yA==",
  "_location": "/neo4j-graphql-js",
  "_phantomChildren": {
    "iterall": "1.2.2"
  },
  "_requested": {
    "escapedName": "neo4j-graphql-js",
    "fetchSpec": "latest",
    "name": "neo4j-graphql-js",
    "raw": "neo4j-graphql-js",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/neo4j-graphql-js/-/neo4j-graphql-js-0.1.18.tgz",
  "_shasum": "2273e85f63541e9f70a710ad4708e0a5453e3096",
  "_shrinkwrap": null,
  "_spec": "neo4j-graphql-js",
  "_where": "/home/jiayu/Documents/guided-spa/graphql",
  "author": {
    "name": "William Lyon"
  },
  "bugs": {
    "url": "https://github.com/neo4j-graphql/neo4j-graphql-js/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "graphql": "git://github.com/graphql/graphql-js.git#npm",
    "lodash": "^4.17.10",
    "neo4j-driver": "^1.6.0"
  },
  "deprecated": false,
  "description": "A GraphQL to Cypher query execution layer for Neo4j. ",
  "devDependencies": {
    "apollo-cache-inmemory": "^1.1.12",
    "apollo-client": "^2.2.8",
    "apollo-link-http": "^1.5.3",
    "apollo-server-express": "^1.3.6",
    "ava": "^0.25.0",
    "babel-cli": "^6.26.0",
    "babel-plugin-transform-async-generator-functions": "^6.24.1",
    "babel-plugin-transform-object-rest-spread": "^6.26.0",
    "babel-plugin-transform-runtime": "^6.23.0",
    "babel-preset-env": "^1.6.0",
    "body-parser": "^1.18.2",
    "express": "^4.16.3",
    "graphql-tag": "^2.9.2",
    "graphql-tools": "^3.0.0",
    "husky": "^0.14.3",
    "lint-staged": "^7.0.0",
    "node-fetch": "^2.1.2",
    "nodemon": "^1.12.1",
    "prettier": "^1.11.1"
  },
  "homepage": "https://github.com/neo4j-graphql/neo4j-graphql-js#readme",
  "license": "Apache-2.0",
  "lint-staged": {
    "*.{js,json,css,md}": [
      "git add",
      "prettier --write"
    ]
  },
  "main": "./dist/index.js",
  "name": "neo4j-graphql-js",
  "optionalDependencies": {},
  "prettier": {
    "singleQuote": true
  },
  "readme": "![](https://circleci.com/gh/neo4j-graphql/neo4j-graphql-js.svg?style=shield&circle-token=d01ffa752fbeb43585631c78370f7dd40528fbd3)\n\n# neo4j-graphql-js\n\nA GraphQL to Cypher query execution layer for Neo4j and JavaScript GraphQL implementations.\n\n_neo4j-graphql-js is in early development. There are rough edges and APIs may change. Please file issues for any bugs that you find or feature requests._\n\n## Installation and usage\n\nInstall\n\n```\nnpm install --save neo4j-graphql-js\n```\n\nThen call `neo4jgraphql()` in your GraphQL resolver. Your GraphQL query will be translated to Cypher and the query passed to Neo4j.\n\n```js\nimport { neo4jgraphql } from 'neo4j-graphql-js';\n\nconst resolvers = {\n  Query: {\n    Movie(object, params, ctx, resolveInfo) {\n      return neo4jgraphql(object, params, ctx, resolveInfo);\n    }\n  }\n};\n```\n\n## What is `neo4j-graphql-js`\n\nA package to make it easier to use GraphQL and [Neo4j](https://neo4j.com/) together. `neo4j-graphql-js` translates GraphQL queries to a single [Cypher](https://neo4j.com/developer/cypher/) query, eliminating the need to write queries in GraphQL resolvers and for batching queries. It also exposes the Cypher query language through GraphQL via the `@cypher` schema directive.\n\n### Goals\n\n* Translate GraphQL queries to Cypher to simplify the process of writing GraphQL resolvers\n* Allow for custom logic by overriding of any resolver function\n* Work with `graphl-tools`, `graphql-js`, and `apollo-server`\n* Support GraphQL servers that need to resolve data from multiple data services/databases\n* Expose the power of Cypher through GraphQL via the `@cypher` directive\n\n## How it works\n\n`neo4j-graphql-js` aims to simplify the process of building GraphQL APIs backed by Neo4j, embracing the paradigm of GraphQL First Development. Specifically,\n\n* The Neo4j datamodel is defined by a GraphQL schema.\n* Inside resolver functions, GraphQL queries are translated to Cypher queries and can be sent to a Neo4j database by including a Neo4j driver instance in the context object of the GraphQL request.\n* Any resolver can be overridden by a custom resolver function implementation to allow for custom logic\n* Optionally, GraphQL fields can be resolved by a user defined Cypher query through the use of the `@cypher` schema directive.\n\n### Start with a GraphQL schema\n\nGraphQL First Development is all about starting with a well defined GraphQL schema. Here we'll use the GraphQL schema IDL syntax, compatible with graphql-tools (and other libraries) to define a simple schema:\n\n```js\nconst typeDefs = `\ntype Movie {\n  movieId: ID!\n  title: String\n  year: Int\n  plot: String\n  poster: String\n  imdbRating: Float\n  similar(first: Int = 3, offset: Int = 0): [Movie] @cypher(statement: \"MATCH (this)-[:IN_GENRE]->(:Genre)<-[:IN_GENRE]-(o:Movie) RETURN o\")\n  degree: Int @cypher(statement: \"RETURN SIZE((this)-->())\")\n  actors(first: Int = 3, offset: Int = 0): [Actor] @relation(name: \"ACTED_IN\", direction:\"IN\")\n}\n\ntype Actor {\n  id: ID!\n  name: String\n  movies: [Movie]\n}\n\n\ntype Query {\n  Movie(id: ID, title: String, year: Int, imdbRating: Float, first: Int, offset: Int): [Movie]\n}\n`;\n```\n\nWe define two types, `Movie` and `Actor` as well as a top level Query `Movie` which becomes our entry point. This looks like a standard GraphQL schema, except for the use of two directives `@relation` and `@cypher`. In GraphQL directives allow us to annotate fields and provide an extension point for GraphQL.\n\n* `@cypher` directive - maps the specified Cypher query to the value of the field. In the Cypher query, `this` is bound to the current object being resolved.\n* `@relation` directive - used to indicate relationships in the data model. The `name` argument specifies the relationship type, and `direction` indicates the direction of the relationship (\"IN\" or \"OUT\" are valid values)\n\n### Translate GraphQL To Cypher\n\nInside each resolver, use `neo4j-graphql()` to generate the Cypher required to resolve the GraphQL query, passing through the query arguments, context and resolveInfo objects.\n\n```js\nimport { neo4jgraphql } from 'neo4j-graphql-js';\n\nconst resolvers = {\n  // entry point to GraphQL service\n  Query: {\n    Movie(object, params, ctx, resolveInfo) {\n      return neo4jgraphql(object, params, ctx, resolveInfo);\n    }\n  }\n};\n```\n\nGraphQL to Cypher translation works by inspecting the GraphQL schema, the GraphQL query and arguments. For example, this simple GraphQL query\n\n```graphql\n{\n  Movie(title: \"River Runs Through It, A\") {\n    title\n    year\n    imdbRating\n  }\n}\n```\n\nis translated into the Cypher query\n\n```cypher\nMATCH (movie:Movie {title:\"River Runs Through It, A\"})\nRETURN movie { .title , .year , .imdbRating } AS movie\nSKIP 0\n```\n\nA slightly more complicated traversal\n\n```graphql\n{\n  Movie(title: \"River Runs Through It, A\") {\n    title\n    year\n    imdbRating\n    actors {\n      name\n    }\n  }\n}\n```\n\nbecomes\n\n```cypher\nMATCH (movie:Movie {title:\"River Runs Through It, A\"})\nRETURN movie { .title , .year , .imdbRating,\n  actors: [(movie)<-[ACTED_IN]-(movie_actors:Actor) | movie_actors { .name }] }\nAS movie\nSKIP 0\n```\n\n## `@cypher` directive\n\n**NOTE: The `@cypher` directive has a dependency on the APOC procedure library, specifically the function `apoc.cypher.runFirstColumn` to run subqueries. If you'd like to make use of the `@cypher` feature you'll need to install [this version of APOC](https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases/tag/3.2.0.5-beta) in Neo4j 3.2.**\n\nGraphQL is fairly limited when it comes to expressing complex queries such as filtering, or aggregations. We expose the graph querying language Cypher through GraphQL via the `@cypher` directive. Annotate a field in your schema with the `@cypher` directive to map the results of that query to the annotated GraphQL field. For example:\n\n```graphql\ntype Movie {\n  movieId: ID!\n  title: String\n  year: Int\n  plot: String\n  similar(first: Int = 3, offset: Int = 0): [Movie]\n    @cypher(\n      statement: \"MATCH (this)-[:IN_GENRE]->(:Genre)<-[:IN_GENRE]-(o:Movie) RETURN o ORDER BY COUNT(*) DESC\"\n    )\n}\n```\n\nThe field `similar` will be resolved using the Cypher query\n\n```cypher\nMATCH (this)-[:IN_GENRE]->(:Genre)<-[:IN_GENRE]-(o:Movie) RETURN o ORDER BY COUNT(*) DESC\n```\n\nto find movies with overlapping Genres.\n\nQuerying a GraphQL field marked with a `@cypher` directive executes that query as a subquery:\n\n_GraphQL:_\n\n```graphql\n{\n  Movie(title: \"River Runs Through It, A\") {\n    title\n    year\n    imdbRating\n    actors {\n      name\n    }\n    similar(first: 3) {\n      title\n    }\n  }\n}\n```\n\n_Cypher:_\n\n```cypher\nMATCH (movie:Movie {title:\"River Runs Through It, A\"})\nRETURN movie { .title , .year , .imdbRating,\n  actors: [(movie)<-[ACTED_IN]-(movie_actors:Actor) | movie_actors { .name }],\n  similar: [ x IN apoc.cypher.runFirstColumn(\"\n        WITH {this} AS this\n        MATCH (this)-[:IN_GENRE]->(:Genre)<-[:IN_GENRE]-(o:Movie)\n        RETURN o\",\n        {this: movie}, true) | x { .title }][..3]\n} AS movie\nSKIP 0\n```\n\n### Query Neo4j\n\nInject a Neo4j driver instance in the context of each GraphQL request and `neo4j-graphql-js` will query the Neo4j database and return the results to resolve the GraphQL query.\n\n```js\nlet driver;\n\nfunction context(headers, secrets) {\n  if (!driver) {\n    driver = neo4j.driver(\n      'bolt://localhost:7687',\n      neo4j.auth.basic('neo4j', 'letmein')\n    );\n  }\n  return { driver };\n}\n```\n\n```js\nserver.use(\n  '/graphql',\n  bodyParser.json(),\n  graphqlExpress(request => ({\n    schema,\n    rootValue,\n    context: context(request.headers, process.env)\n  }))\n);\n```\n\nSee [/examples](https://github.com/neo4j-graphql/neo4j-graphql-js/tree/master/example/graphql-tools) for complete examples using different GraphQL server libraries.\n\n## Benefits\n\n* Send a single query to the database\n* No need to write queries for each resolver\n* Exposes the power of the Cypher query langauge through GraphQL\n\n## Test\n\nWe use the `ava` test runner.\n\n```\nnpm install\nnpm build\nnpm test\n```\n\nCurrently we only have simple unit tests verifying generated Cypher as translated from GraphQL queries and schema. More complete tests coming soon.\n\n## Examples\n\nSee [/examples](https://github.com/neo4j-graphql/neo4j-graphql-js/tree/master/example/graphql-tools)\n\n## Features\n\n* [x] translate basic GraphQL queries to Cypher\n* [x] `first` and `offset` arguments for pagination\n* [x] `@cypher` schema directive for exposing Cypher through GraphQL\n* [x] Handle enumeration types\n* [x] Handle fragments\n* [ ] Handle interface types\n* [ ] Handle inline fragments\n* [ ] Ordering\n\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/neo4j-graphql/neo4j-graphql-js.git"
  },
  "scripts": {
    "build": "babel src --presets babel-preset-env --out-dir dist",
    "precommit": "lint-staged",
    "prepublish": "npm run build",
    "pretest": "npm run build",
    "start": "nodemon ./example/graphql-tools/movies.js --exec babel-node -e js",
    "test": "ava test/cypherTest.js test/augmentSchemaTest.js --verbose"
  },
  "version": "0.1.18"
}
